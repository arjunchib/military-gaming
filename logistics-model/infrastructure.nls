globals [railhead source]

breed [stations station]
undirected-link-breed [tracks track]
breed [junctions junction]
undirected-link-breed [roads road]
breed [trains train]

trains-own [current-station previous-station speed supply capacity]
tracks-own [health weight]
roads-own [weight]
stations-own [supply]

to setup-infrastructure
  setup-junctions
  setup-roads
  setup-stations
  setup-tracks
  setup-trains
  set railhead one-of stations with [label = "Landen"]
  set source one-of stations with [label = "Aix-la-Chapelle"]
end

to step-infrastructure
  if ticks mod 24 = 0 [update-railhead]
  update-tracks
  update-trains
end

to setup-junctions
  let junction-data csv:from-file "junctions.csv"
  set-default-shape junctions "dot"
  foreach junction-data [ [data] ->
    let x item 0 data
    let y item 1 data
    create-junctions 1 [
      setxy x y
      set label item 2 data
    ]
  ]
  ask junctions [set color white]
  ask junctions [set hidden? true]
end

to setup-roads
  let road-data csv:from-file "roads.csv"
  set-default-shape roads "road"
  foreach road-data [ [data] ->
    let s item 0 data
    let t item 1 data
    ask junctions with [label = s] [create-roads-with junctions with [label = t]]
  ]
  ask roads [
    set color white
    set weight link-length
  ]
end

to setup-stations
  let station-data csv:from-file "stations.csv"
  set-default-shape stations "triangle"
  foreach station-data [ [data] ->
    let x item 0 data
    let y item 1 data
    create-stations 1 [
      setxy x y
      set label item 2 data
    ]
  ]
  ask stations [
    set color green
    set size 1.5
  ]
end

to setup-tracks
  let health5 [130 255 56]

  let track-data csv:from-file "tracks.csv"
  set-default-shape tracks "train"
  foreach track-data [ [data] ->
    let s item 0 data
    let t item 1 data

    ask stations with [label = s] [create-tracks-with stations with [label = t]]

    ask tracks [
      set health 100
      set color health5
      set weight link-length
    ]
  ]
end

to setup-trains
  set-default-shape trains "train freight engine"
  
  let start-station one-of stations with [label = "Aix-la-Chapelle"]
  
  let train-speed 10 ;km/h 
  
  create-trains 6
  [
    setxy [xcor] of start-station [ycor] of start-station
    set supply 0
    set capacity 200 ;tons
    set speed train-speed * map-scale
    set current-station start-station
    set color yellow
    set size 2
  ]
end

to update-trains
  ask trains [
    if-else distance current-station <= speed [
      move-to current-station
      let in-transfer? false
      if current-station = railhead and supply > 0 [
        set in-transfer? true
        let transfer-supply 10
        if supply < 10 [
          set transfer-supply supply
        ]
        ask current-station [set supply supply + transfer-supply]
        set supply supply - transfer-supply
      ]
      if current-station = source and supply < capacity [
        set in-transfer? true
        set supply supply + 10
      ]
      if not in-transfer? [
        let dest-station railhead
        if supply <= 0 [set dest-station source]
        let shortest-path (list current-station)
        ask current-station [
          nw:set-context stations tracks
          set shortest-path nw:turtles-on-weighted-path-to dest-station weight
        ]
        let next-station item 1 shortest-path
        face next-station
        set previous-station current-station
        set current-station next-station
      ]
    ][
      let current-track track [who] of previous-station [who] of current-station
      forward speed * random-float 1 * [health] of current-track / 100
    ]
  ]
end

to update-tracks
  ;; Repair tracks
  ask railhead [
    nw:set-context stations tracks
    let shortest-path nw:weighted-path-to one-of stations with [label = "Aix-la-Chapelle"] weight
    let repairable-tracks link-set shortest-path
    ask min-one-of repairable-tracks [health] [
      let repair-ammount 10 * time-scale
      if-else repair-ammount + health > 100 [
        set health 100
      ][
        set health health + repair-ammount
      ]
    ]
  ]
  
  ;; Update track colors
  let health5 [130 255 56]
  let health4 [147 193 42]
  let health3 [164 131 28]
  let health2 [181 69 14]
  let health1 [199 7 0]
  let c 55

  ask tracks [
    if health >= 0 and health < 20 [
      set c health1
    ]
    if health >= 20 and health < 40 [
      set c health2
    ]
    if health >= 40 and health < 60 [
      set c health3
    ]
    if health >= 60 and health < 80 [
      set c health4
    ]
    if health >= 80 and health <= 100 [
      set c health5
    ]
    set color c
  ]
end

to update-railhead
  let train-repair 50 ;per day
  set railhead item 0 sort-by [[s1 s2] -> railhead-value s1 > railhead-value s2] stations
  ask stations [set color green]
  ask railhead [set color red]
end

to-report dist-from-railhead
  let total-dist 0
  ask german-corps [
    set total-dist total-dist + distance railhead
  ]
  report total-dist / map-scale / 6
end

to-report railhead-value [my-station]
  if my-station = source [report 0]
  let my-junction one-of junctions with [label = [label] of my-station]
  
  let value 0
  let my-german-corps max-one-of german-corps [distance source]
  ask my-german-corps [
    nw:set-context junctions roads
    let dist-from-station 0
    ask current-junction [set dist-from-station nw:weighted-distance-to my-junction weight]
    if is-number? dist-from-station [
      if dist-from-station > 40 * map-scale and dist-from-station < 90 * map-scale [
        ask my-station [
          set value value + 1 / distance source
        ]
      ]
    ]
  ]
  report value
end