breed [german-corps a-german-corps]
breed [supply-companys supply-company]

german-corps-own [supply capacity current-junction speed units attrition]
supply-companys-own [supply capacity current-junction speed corps]

to setup-germans
  
  set-default-shape german-corps "square"
  
  let start-junction one-of junctions with [label = "Brussels"]
  
  create-german-corps 6 [
    setxy [xcor] of start-junction [ycor] of start-junction
    set supply 100
    set current-junction start-junction
    set color yellow
    set size 1
    set speed german-speed * time-scale * map-scale
    set units german-num-units
    set capacity german-supply-capacity
  ]
  
  let german-corps-list []
  ask german-corps [ set german-corps-list lput self german-corps-list ] 
  
  foreach german-corps-list [ my-german-corps ->
    create-supply-companys 0 [
      setxy [xcor] of my-german-corps [ycor] of my-german-corps
      set supply 0
      set capacity 100
      set current-junction start-junction
      set speed supply-company-speed * time-scale * map-scale
      set corps my-german-corps 
    ]
  ]
end

to step-german
  check-french-corps
  supply-german-corps-continous
end

;; dest_label: label of the destination
;; This proc moves the German corps along the shortest path between the 
;; current location of the German corps and the destination
to move-german-corps [my-german-corps dest-junction]
  ask my-german-corps [
    nw:set-context junctions roads
    if-else distance current-junction <= speed [
      move-to current-junction
      let shortest-path (list current-junction)
      ask current-junction 
      [
        set shortest-path nw:turtles-on-weighted-path-to dest-junction weight
      ]
      let next-junction item 0 shortest-path
      if length shortest-path > 1 [set next-junction item 1 shortest-path]
      face next-junction
      set current-junction next-junction
    ][
      set speed german-speed * time-scale * map-scale
      forward speed * (random-float 0.5 + 0.75)
    ]
  ]
end

;; Check to see if French corps are nearby
;; If within pursue-rad => Pursue
;;      If within attack-rad => Attack
;; Else keep moving towards Meaux
to check-french-corps
  ask german-corps 
  [ 
    ;; Only pursue/attack french-corps if they're alive
    if supply > 20 [
      ifelse any? french-corps in-radius pursue-distance
      [
        ;; If in attack-rad => attack
        ifelse any? french-corps in-radius 0.5
        [ 
          attack-french-corps 
        ]
        ;; Else, keep moving toward
        [ 
          pursue-french-corps
        ]
      ]
      [ 
        ;print "Not near French-corps or French-corps are all dead; Moving towards Meaux"
        move-german-corps self one-of junctions with [label = "Meaux"]
      ]
    ]
  ]
end

to pursue-french-corps
  ;print "Pursuing French-corps" 
  
  ;; Follow French's movement direction
  move-german-corps self [current-junction] of min-one-of french-corps [distance myself]
end

to attack-french-corps
  ;; Reduce french-corps size?
  ;print "Attacking french-corps"
  
  ;; Fight
  ;; For now just decrease the size of french-corps
  set attrition german-attrition
  let damage-given attrition * units * (random-float 0.5 + 0.75)
  let damage-taken 0
  ask one-of french-corps in-radius 0.5 [
    set plunder 0
    set attrition allied-attrition
    set damage-taken attrition * units * (random-float 0.5 + 0.75)
    set units units - damage-given
    if units <= 0 [die]
  ]
  set units units - damage-taken
  
  ;; Lose supply
    ask german-corps [if supply > 0 [set supply supply - supply-decay * time-scale ]]
end

to supply-german-corps-continous
  ask german-corps [
    ;; For now , just make it indirectly proportional:
    let dist-railhead distance railhead
    
    let supply-gain number-supply-companies * dist-railhead / (supply-company-speed * time-scale * map-scale) / 2 * supply-company-capacity
    if dist-railhead = 0 [set supply-gain number-supply-companies * supply-company-capacity]
    ask railhead [
      if supply < supply-gain [
        set supply-gain supply
      ]
      set supply supply - supply-gain
    ]
    if-else supply + supply-gain >= capacity [
      set supply capacity
    ][
      set supply supply + supply-gain
    ]
  ]
end

to supply-german-corps
  ask supply-companys [
    
    if current-junction = railhead and distance current-junction <= speed and supply < capacity [
      move-to current-junction
      set supply supply + 10
      if supply >= capacity [
        set supply capacity
      ]
    stop
    ]
    
    if supply = 0 [
      let railhead-label [label] of railhead
      move-supply-company self one-of junctions with [label = railhead-label]
      stop
    ]
    
    if distance corps <= speed * 2 [
      set supply supply - 10
      ask corps [
        set supply supply + 10
        if supply >= capacity [
          set supply capacity
        ]
      ]
      if-else [supply] of corps = [capacity] of corps [
        set supply 0
      ][
        move-supply-company self [current-junction] of corps
      ]
      stop
    ]
    
    move-supply-company self [current-junction] of corps
  ]
end

to move-supply-company [my-supply-company dest-junction]
  ask my-supply-company [
    if-else distance current-junction <= speed [
      move-to current-junction
      if dest-junction = nobody [stop]
      let shortest-path (list current-junction)
      ask current-junction [
        nw:set-context junctions roads
        set shortest-path nw:turtles-on-weighted-path-to dest-junction weight
      ]
      ;show current-junction
      ;show dest-junction
      if is-list? shortest-path and length shortest-path > 1 [
        set current-junction item 1 shortest-path
        face current-junction
      ]
    ] [
      set speed supply-company-speed * time-scale * map-scale
      forward speed * (random-float 0.5 + 0.75)
    ]
  ]
end